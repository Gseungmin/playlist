## 서비스 설계
1. 유튜브 플레이리스트와 같은 플레이리스트를 효율적으로 구현해야 한다.
2. 기본적으로 대규모 트래픽을 가정하고, 서버와 데이터베이스의 최적화를 목표로 한다.
3. 또한 레디스가 대규모 요청을 충분히 처리할 수 있음을 가정한다.

## 서비스 상세 요구사항
1. 플레이리스트를 생성할 수 있다. 생성은 대규모로 진행된다.
2. 플레이리스트의 조회는 모든 유저가 가능하지만, 플레이리스트 업데이트는 생성한 유저만 가능하다.
3. 플레이리스트안의 노래들을 순서를 변경할 수 있다. 여러개를 한번에 변경할 수 있다.
4. 플레이리스트에 중복된 노래를 추가할 수 없으며, 노래는 최대 1000개까지 추가할 수 있다.

## 서비스 구현
### 대규모 플레이리스트 생성

[문서화](https://jseungmin.notion.site/1f1e2fd91ae2808c8ba9d61abe8a7b27?pvs=4) [PR](https://github.com/Gseungmin/playlist/pull/3)

1. 플레이리스트 생성시 레디스 캐시와 배치 인서트를 활용한다.
2. 요청이 들어오면 먼저 캐시에 저장후, 사용자에게 응답한다.
3. 이후 1000ms애 한번 배치 처리를 통한 벌크 인서트를 진행한다.
4. 단, 대규모 트래픽시 1000ms라 하더라도 메모리 문제로 이어질 수 있으므로 특정 카운트에 도달하면 미리 벌크 인서트를 진행한다.

### 플레이리스트 순서 정보 관리

[문서화](https://jseungmin.notion.site/1f1e2fd91ae2808c8ba9d61abe8a7b27?pvs=4) [PR](https://github.com/Gseungmin/playlist/pull/4)

1. 플레이리스트 순서 정보 관리를 위해 Gap-based numbering 방식 도입
2. 인덱스 업데이트 비효율을 줄이기 위해 배치 업데이트 진행 (추후 인덱스 제거 검토)
3. 리오더링 시 메모리 비효율을 최소화하기 위해 DTO 프로젝션 도입

